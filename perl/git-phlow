#!/usr/bin/perl
require 5.000;
use strict;
use Carp;
use Cwd;

# File version
our $VERSION    = "1.0";                             #major.minor
our $PATCH      = "1";                               #patch

use Getopt::Long;
use Pod::Usage;
use JSON::PP;

# Holds the global variables that are used to cache the value of our options
our %options;

# The white-listed phlow commands
our %valid_commands = (
  addremove        => [1],
  defaultbranch    => [1],
  issuebranch      => [1],
  web              => [1],
  mkalias          => [0],
  workon           => [1]
);

GetOptions(
  (
    "issue=s"              => \$options{issue},
    "force"                => \$options{force},
    "verbose!"             => \$options{verbose},
		"help"                 => \$options{help},
    "man"                  => sub { pod2usage(-exitval => 0, -verbose => 2) }	)
) || pod2usage(-exitval => 1, -verbose => 0);

our $Phlowcommand = shift;

validate_context();

eval '&'.$Phlowcommand.'(@ARGV)';
if ($@){
  warn $@;
}



exit(0);

###################################################

# Below is all the POD documentation following the conventional chapters as described in (http://perldoc.perl.org/perlpod.html). The functions are implemented after the last pod chapter COMMANDS is declared. The commands have POD text, the helper functions doesn't

=pod

=head1 NAME

This script is related to "The Phlow" described in detail in L<A Praqmatic Workflow|http://www.praqma.com/stories/a-pragmatic-workflow/>

It provides the various features that are required to support all user scenarios of the Phlow.

=over

=item B<Copyright:>

Praqma, 2017, L<www.praqma.com|http://www.praqma.com>

=item B<License:>

M.I.T.

=item B<Repository:>

L<github.com/praqma/the-phlow|http://github.com/praqma/the-phlow>

=item B<Support:>

Use the L<issue system|http://github.com/praqma/the-phlow/issues> in the repo

=back

=head1 SYNOPSIS

  git phlow <command> [options] [arguments]
  git phlow --man|--help

All options can be shortend to their shortest unambigious form and you can use one or two dashes in front of options, as your temper prefers - we don't care.

E.g. C<-h> can substitute C<--help>.

=head1 OPTIONS

The valid phlow commands are listed below.

  phlow addremove [--help][--verbose]
  phlow defaultbranch


=head1 DESCRIPTION

The script is helping implementing the git gymnastics required bot as an end user and on the CI servers to support "the Phlow".

The most simple use of it is to clone the repo to your PC, and then link the perl folder to a directory that is in your C<$PATH> like this:

    git clone https://github.com/Praqma/the-phlow.git
    ln -s ./the-phlow/perl ~/opt/phlow

and then add /Users/you/opt/phlow to your C<$PATH> in C<.zshrc> or C<.bashrc> or what ever you are using.

Hereafter you will hvae access to all the phlow commands like this

    git phlow addremove
    git phlow work-on
    ...

=head1 COMMANDS

=cut

sub web($) {
=head2 web

C<git phlow web [--issue number]>

Opens your current context in a web browser. If you are on an issue branch, then it will take you directly to the corresponding issue on GitHub. Otherwise it will take you to the repo's web site.

=cut
  my $url = 'https://github.com/';
  my $hubname = hubname();
  if (defined($hubname)){
    $url =$url.$hubname;
    if($options{issue}){
      croak 'I want an integer!' unless ($options{issue} =~ /^\d+$/);
      $url = $url.'/issues/'.$options{issue};
    } else{
      my $issue = issue_no_from_branch();
      print "DEBUG: \$issue: $issue\n";
      defined($issue) && do {$url = $url.'/issues/'.$issue};
    }
  }
  `open $url`;
}

sub addremove(){

=head2 addremove

C<addremove> is implementing Mercurials command of the same name.

It doesn't take any parametes. It simply synchronizes your current work tree
with the index; It adds the files you have added or modified and removes the files that you may removed.

=cut
	cmd(command => "git add -A .", verbose => $options{verbose} )

};

sub defaultbranch(){

=head2 defaultbranch

C<defaultbranch> Returns the default branch. This is a setting on the GitHub repository.

=cut
  print get_default_branch()."\n";
}

sub mkalias (){

=head2 mkalias

C<git phlow mkalias [--force]>

Creates the aliases foreach phlow command. Which will enable you to use the flow commands as native git commands:

   git workon 3

Instead of the full length phlow command:

  git phlow workon 3

It will not overwrite existing aliases with clashing names unless you applu C<--force>

=cut

  foreach my $cmd (sort keys %valid_commands){
    my $alias = "phlow $cmd";
    if ($valid_commands{$cmd}[0]){
      my $curalias = cmd(
        command => "git config --global --get alias.$cmd",
        verbose => $options{verbose},
        die_on_err => 0);
      chomp($curalias);
      my $action = ($curalias ne '')? "Overwriting" : "Creating";
      if ($curalias ne $alias){
        if ($curalias ne '' && not defined($options{force})){
          print STDERR "Not overwriting the existing alias '$cmd' unless you apply --force\n";
        } else {
          print "$action the '$cmd' alias\n";
          cmd(
            command => "git config --global --add alias.$cmd \"$alias\"",
            verbose => $options{verbose});
        }
      } else{
        print "The alias '$cmd' is already set correct\n";
      }
    }
  }
}

sub issuebranch($){
  my $issue = shift;
  print issue_branch_name($issue)."\n";
}

sub workon ($){
  my $issue = shift;
  croak 'I want an integer!' unless ($issue =~ /^\d+$/);
  croak "There's only room for one argument" if defined(shift);

  my $branchname = issue_branch_name( $issue);
  my $shared_branchname = 'shared/'.$branchname;
  my $delivered_branchname = 'delivered/'.$branchname;

  # Get a list of branches that can be reused
  my @branches = cmd(
    command => "git branch --list $branchname $shared_branchname $delivered_branchname",
    verbose => $options{verbose},
    die_on_err => 0,
    return_array => 1);

  # Chomp and clean up output from the git command, transform to a map
  if (@branches){
    my %branchmap;
    foreach my $existb (@branches){
      $existb =~ s/^\**\s*//;
      chomp($existb);
      $branchmap{$existb} = '';
    }

    # If there are more then one potentially reusable branch then '--force' is required to proceed
    if (scalar @branches >1 && not $options{force}){
      print "Hmm - seems like you have too many branches related to issue '$issue' hanging around:\n\n";

      foreach (sort keys %branchmap){
        print  "  $_\n";
      }

      print "\nThere can be only one! Either clean up a little or run again with '--force'\n";

      exit 1;
    }

    if (defined($branchmap{$branchname})){
      print "Reusing branch '$branchname'\n";
      exit 0;
    }

    if (defined($branchmap{$shared_branchname})){
      print "Reusing branch '$shared_branchname'\n";
      exit 0;
    }

    if (defined($branchmap{$delivered_branchname})){
      print "Reusing branch '$delivered_branchname'\n";
      exit 0;
    }

  } else{ # no branches ot reuse
    cmd (
      command => "git fetch origin",
      verbose => $options{verbose} );
    cmd (
      command => "git checkout -b $branchname origin/".get_default_branch(),
      verbose => $options{verbose})
  };




  # BRANCHNAME=`git issue-branch $1`; \
  # DELIVEREDBRANCHNAME=delivered/$BRANCHNAME; \
  # if [[ `git branch --list $DELIVEREDBRANCHNAME` =~ $DELIVEREDBRANCHNAME ]]; \
  # then \
  #   git branch -m $DELIVEREDBRANCHNAME $BRANCHNAME; \
  #   git checkout $BRANCHNAME; \
  # else \
  #   git checkout $BRANCHNAME   2> /dev/null; \
  #   git fetch origin \
  #   && git checkout -b $BRANCHNAME origin/`git default-branch`; \
  # fi; \
  # if [[ `git status` =~ "fast-forwarded" ]]; \
  # then \
  #   git pull; \
  # fi; \
  # git issue-wip $1; \
}

######## Non exposed helper functions

sub validate_context(){
	unless (defined $valid_commands{$Phlowcommand}){
		print STDERR "$Phlowcommand is not a legal command\n";
		pod2usage(-exitval => 1, -verbose => 1)
	};
  defined $options{help} && pod2usage(
   -verbose => 99,
   -exitval => 1,
   -sections => [ "COMMANDS/".$Phlowcommand ]
  );
  defined( $options{verbose} ) ||  do {$options{verbose} = 0};
  $options{verbose} && print "Phlow $Phlowcommand\n";
};


sub hubname(){
  my $remoteurl = cmd(
    command => 'git config --get remote.origin.url',
    verbose => $options{verbose} );
  my ($srv, $hubname) = split /:/, $remoteurl;
  $hubname =~ s@//github.com/@@g;
  $hubname =~ s/.git$//g;
  chomp($hubname);
  return $hubname;
}

sub gettoken(){
  my $token = cmd(
    command => 'git config --global --get ghi.token',
    verbose => $options{verbose});
  chomp($token);
  if ($token =~ s/^!//){
    $token = cmd(
      command => $token,
      verbose => $options{verbose});
  };
  chomp($token);
  return $token;
}

sub cmd ($) {
  my %opt = @_;
  croak "input parameter for key 'command' required" unless ( $opt{command} );
  defined( $opt{die_on_err} )   ||  do {$opt{die_on_err}   = 1};
	defined( $opt{merge_errout} ) ||  do {$opt{merge_errout} = 1};
	defined( $opt{verbose} )      ||  do {$opt{verbose}      = 0};
	defined( $opt{return_array} ) ||  do {$opt{return_array} = 0};
  my $cmd = ($opt{merge_errout})? $opt{command} . ' 2>&1' : $opt{command};
	$opt{verbose} && print $opt{command}."\n";
  my @res = qx($cmd);
  # Report errors unless we expect the call to generate non-zero exit value
  unless ( not $opt{die_on_err} ) {
    if ($?) {
      croak "Execution of [$cmd] returned a non-zero value (".( ($?) / 256).")";
    }
  };
  return ( $opt{return_array} ) ? @res : join( '', @res );
}

sub issue_branch_name ($) {
  my $issue = shift;
  croak 'I want an integer!' unless ($issue =~ /^\d+$/);
  croak "There's only room for one argument" if defined(shift);
  my $api = 'https://api.github.com/repos/'.hubname().'/issues/'.$issue;
  my $json = ghapi( uri => $api);
  my $branchname = $json->{title};
  if (defined $branchname){
    $branchname =~ s/[\!\.\"\£\$€\%\&\?\*\@\:\;\\\/\[\]\,\:\'\+]//g;
    $branchname = "$issue-".$branchname;
    $branchname =~ s/[ _]/-/g;
    while ($branchname =~ s/--/-/g){};
    $branchname =~ s/-$//g;
  }
  return lc($branchname);
};

sub ghapi ($){
  my %opt = @_;
  croak "'uri' is required" unless defined($opt{uri});
  my $cmd = 'curl -s -u :'.gettoken().' '.$opt{uri};
  my $raw_json = &cmd( command => $cmd, verbose => $options{verbose});
  return JSON::PP->new->utf8->relaxed([1])->decode($raw_json);
};

sub issue_no_from_branch (){
  my $retval;
  my $branch = &cmd( command => "git symbolic-ref --short HEAD",
    verbose => $options{verbose});
  if ( $branch =~ /^(\d+)/ || $branch =~ /^delivered\/(\d+)/){
    $retval = $1;
  };
  return $retval;
};

sub get_default_branch(){
  my $cmd = 'curl -s -u :'.gettoken()
    .' https://api.github.com/repos/'.hubname();
  my $raw_json = &cmd(
    command => $cmd,
    verbose => $options{verbose});
  my $json = JSON::PP->new->utf8->relaxed([1])->decode($raw_json);
  return $json->{default_branch};
}




__END__
